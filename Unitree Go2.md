![img](https://doc-cdn.unitree.com/static/2023/9/5/bc447ffc02cf442186d8b7d57e52fb7d_754x448.jpeg)

| 名称          | 意思                                                   |
| ------------- | ------------------------------------------------------ |
| DDS DOMAIN    | 一个通信领域（像一个频道/聊天室）                      |
| TOPIC A/B/... | 不同主题（每个话题一种数据类型，例如 IMU、图像等）     |
| DATA WRITER   | 发布者（Publisher）负责“写入”某个 Topic 的数据         |
| DATA READER   | 订阅者（Subscriber）负责“读取”某个 Topic 的数据        |
| QoS           | 质量策略（Quality of Service），用于控制可靠性、顺序等 |
| FILTER        | 过滤器，限制接收者只接收某种内容/频率的数据            |



DDS 允许多个数据源（Writer）同时向多个主题（Topic）写数据，多个订阅者（Reader）根据自己的需求订阅感兴趣的 Topic，并通过 QoS 和 Filter 实现实时、高效、可控的数据传输。



---

> （Odometry，里程计）Odom 是指机器人在自身坐标系下“推算”出来的位置和速度数据。



> IMU (惯性测量单元) 是机器人“自我感知”传感器
>
> 负责实时提供姿态/角速度等信息，帮助判断运动状态

---



>  **STEP（产品数据交换格式）**

相当于工业界的**“万能翻译官”**，专门解决不同软件之间传文件时的“语言不通”问题

>  **URDF（机器人说明书）**

机器人的**“身份证+体检报告”**，描述相关结构



| **功能**     | STEP                           | URDF                |
| :----------- | :----------------------------- | :------------------ |
| **适用对象** | 所有工业产品（螺丝/汽车/飞机） | 只针对机器人        |
| **文件内容** | 长啥样 + 怎么造                | 怎么动 + 哪里不能碰 |
| **常用软件** | CAD软件（如SolidWorks）        | 机器人软件（如ROS） |

- **STEP**是给**工厂老师傅**看的（这零件该怎么生产）
- **URDF**是给**程序员**看的（这机器人该怎么编程）





---

**Wi-Fi STA（Station）是“终端模式”**，设备作为“上网客户端”；
**Wi-Fi AP（Access Point）是“热点模式”**，设备作为“网络提供者”。



- **Wi-Fi STA** ： Go2 连接至环境中某 **Wi-Fi** 热点，实现外网访问能力。
- **Wi-Fi AP** ： Go2 自带的热点，为自建的局域网，支持手机等设备连接。
- **4G** ：Go2 自带的 4G 物联网卡连接至运营商基站，实现外网访问能力。

优先级**：Wi-Fi STA > 4G** (同时开启的情况)



---

### LiDAR服务：

基于激光雷达的应用开发内容，并明确提供了**两种地图构建方式**，分别是：

✅ **Voxel Map（体素地图）**

- 三维稠密点云地图（3D Voxel Map）
- 用于构建完整的环境体积表示

✅ **Height Map（高度地图）**

- 2.5D 高度图
- 每个平面栅格记录一个最大高度值
- 适合运动规划和地形分析



![img](https://doc-cdn.unitree.com/static/2023/8/8/33c87925266a4e6bac638247d3f30552_7453x1979.jpg)



**【感知采集】→【数据同步 + 地图构建 + 规划】→【运动控制】**

```
【激光雷达】
   ↓ 串口数据
【Unilidar SDK】
   ↓ 点云 + IMU
【Unilidar Node】
   ↓ 去畸变点云（Undeskewed Cloud）
 → Voxel Mapping → 空间地图构建 + 可视化
 → Height Mapping → Motion Planning（简化地图 + 运动规划） → Robot

【Robot】
 ↑ 指令执行 + 状态反馈 ← Motion Control ← Unilidar Node

```



---

### SLAM服务：









---

### ROS ---（机器人操作系统）

> 它并不是一个传统意义上的“操作系统”，而是一套**面向机器人开发的通信框架和工具链**，帮你实现模块化开发、消息传递、传感器处理、运动控制等



**核心概念：**

| 概念        | 含义                                    |
| ----------- | --------------------------------------- |
| **Node**    | 节点：一个独立的模块（比如雷达驱动）    |
| **Topic**   | 话题：Node 之间用来传递消息的“广播频道” |
| **Message** | 消息：数据结构，比如 IMU、激光点云等    |
| **Service** | 服务：像 API 调用，一问一答的通信方式   |
| **Bag**     | 数据包：可录制 ROS 消息，用于回放和调试 |



---



### RViz --- ROS Visualization Tool

>  它是 ROS 自带的图形化工具，用于**可视化机器人状态、地图、激光雷达点云、位姿轨迹、IMU 数据等**

```
作用:

看地图建得好不好
看雷达是否工作
看机器人当前的方向、位置
点选目标点让机器人导航
```



图形界面:

| 模块       | 显示内容       |
| ---------- | -------------- |
| Map        | 2D/3D 地图     |
| LaserScan  | 红点点激光点云 |
| TF         | 坐标系关系     |
| RobotModel | 机器人体模型   |
| PoseArray  | 当前位置姿态等 |



---



![image-20250519204522524](C:\Users\Todd\AppData\Roaming\Typora\typora-user-images\image-20250519204522524.png)



```
ssh（CLI） or vnc（GUI） 远程连接 拓展坞（它运行 Ubuntu）
在拓展坞上写 ROS 节点（订阅雷达、IMU、发布控制）
通过拓展坞发出的指令，控制狗本体运动

✅ 用任意主机（Win/Mac/Linux）通过 SSH 连上拓展坞
✅ 在拓展坞（Ubuntu 20.04）中运行你的 ROS 节点 / SDK / SLAM 程序
✅ 拓展坞与狗本体通过网口连接，实现控制/感知/建图闭环，拓展坞也处理传感器数据，输出地图等结果
```



❶ 「我把拓展坞和 Go2 连好后，拓展坞的网口就被占用了，那我是不是应该用无线网卡远程连接它？」
❷ 「如果我不用无线网卡，每次拔网线来换我电脑开发，这样是不是很麻烦？」



### RJ45网口冲突问题的最优解

| 项目                   | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 🧠 连接方式逻辑         | 拓展坞的唯一 RJ45 口连接着 Go2，用于控制、收数据             |
| 🧠 二次开发需要连拓展坞 | 你主机要通过 SSH/VNC 登录拓展坞 → **无法再插网线连主机**     |
| ✅ 最优方案             | ✅ 给拓展坞加一个**无线网卡**，让它连上局域网（或者热点），你主机也连这个网络 |
| 🎯 效果                 | 你主机随时可以远程连拓展坞 → 运行程序、实时调试控制 Go2，无需碰线 |



## **用网线拔来拔去开发体验差，风险也高**

| 方案                   | 问题描述                                                     |
| ---------------------- | ------------------------------------------------------------ |
| ❌ 拔 RJ45 网线换你电脑 | 每次要从狗 ↔ 拓展坞的连线中拔出来 → 插你电脑 → 再还原，非常麻烦 |
| ❌ 频繁插拔影响接口寿命 | 接头损耗快、容易接触不良                                     |
| ❌ 容易断控制连接       | 每次拔线可能断掉狗和拓展坞之间的实时控制 / ROS 网络结构      |
| ❌ 可能配置丢失         | 网络切换过程中丢失 IP、ROS 节点找不到彼此                    |



#### 整体的架构：

```
[你的主机] (虚拟机里的 Ubuntu)
     │
     ├── SSH 登录拓展坞（命令行开发、运行 ROS 节点）
     └── VNC 远程桌面（可视化、运行 RViz）
        ↓
[拓展坞 Ubuntu]（通常是 Orin NX）
     ├── 运行 ROS2、SLAM、Unilidar SDK
     ├── 订阅传感器数据（IMU、雷达、相机）
     └── 控制 Go2 主控（发 cmd_vel 控制运动）

```

> 你写的所有代码、调试操作，都是在 **拓展坞的 Ubuntu 系统里进行的**，狗只是“执行机器”。



#### 能不能用虚拟机？

可以，但看你**要做哪一部分**：

| 工作内容                 | 你主机平台要求                       |
| ------------------------ | ------------------------------------ |
| 远程 SSH 登录拓展坞      | ✅ 任意平台（包括虚拟机）             |
| 用 RViz 查看远程雷达点云 | ✅ 建议用 Ubuntu（或支持 X11 的系统） |
| 直接在主机上跑 ROS 节点  | ⚠️ 建议避免（更复杂，除非做多机协同） |

> ✅ 所以：**你的主机只需要能连接拓展坞就行**，哪怕它是虚拟机，只要能用 SSH 就可以开发。



---



#### 建议在远程主机先git相关的SDK，采用多级向下推送的方式，避免拓展坞Ubuntu段**配置代理**的繁琐：

```
你（远程主机，已配置好代理）
   ↓ 拉取资源（如 GitHub 上的 SDK）
   ↓ 使用 scp / rsync
堡垒机（中转服务器）
   ↓ 使用 scp / rsync 内网拷贝
拓展坞 Ubuntu（实际运行环境）
```



scp层层推送简化步骤：

```
# 主机：
tar -czvf go2-sdk.tar.gz go2-sdk/
scp go2-sdk.tar.gz user@<堡垒机IP>:/home/user/

# 堡垒机：
scp go2-sdk.tar.gz ubuntu@<拓展坞IP>:/home/ubuntu/

# 拓展坞：
tar -xzvf go2-sdk.tar.gz
```



---



**Go2 的内置电脑**不具备直接访问互联网的能力，但具备通过局域网与其他设备（如拓展坞）通信的能力

| 能力类别              | 是否具备 | 说明                                                         |
| --------------------- | -------- | ------------------------------------------------------------ |
| **访问公网（上网）**  | ❌ 否     | Go2 本体内置控制器系统为封闭环境，默认无 DNS 配置、无代理、也无法通过网关上网 |
| **局域网通信（LAN）** | ✅ 是     | 支持以太网口固定 IP 通信，可接入 `192.168.123.X` 段与拓展坞通信 |
| **远程 SSH / 登录**   | ❌ 否     | 不开放 SSH 服务，无法作为开发主机连接                        |
| **数据接口访问**      | ✅ 是     | 可通过 UDP / ROS 接口订阅状态、发布控制命令等                |



给拓展坞（运行 Ubuntu 的小主机）插上一张无线网卡，并连接上一个 Wi-Fi 网络时，拓展坞就会通过 DHCP 自动获取一个 IP 地址



## **如果没有无线网卡，拓展坞就没有 IP 吗？**

> ❌ 不一定没有，但要分情况：

| 拓展坞情况                 | 有没有 IP？         | 说明                                                        |
| -------------------------- | ------------------- | ----------------------------------------------------------- |
| ✅ 连接有线网络（如路由器） | ✅ 有                | 可通过 DHCP 分配 IP，或者你手动设静态 IP                    |
| ❌ 没连任何网（只有狗）     | ⚠️ 没有外部可访问 IP | 此时只有和狗通信的专用 IP（如 192.168.123.X），你无法远程连 |
| ✅ 加了无线网卡连接 Wi-Fi   | ✅ 有                | 可从 Wi-Fi 拿到 IP，你就可以远程 SSH 连上了                 |

📌 所以如果你不接网线又没无线网卡，**拓展坞确实就没有可以让你远程访问的 IP。*

 📌SSH 连接对象是拓展坞的 IP



---



### 关于测试电脑和Go2内置电脑通信： ------ 进行基本的运动控制测试和状态校验

> 用户电脑连接 Go2 的内置电脑，本质上是为了调用其开放的接口（如状态读取、控制指令），以进行基本的运动控制测试和状态校验，并不涉及二次开发；其目的是确认设备运行稳定，为后续基于拓展坞的深度开发打好基础

```
连接 Go2 本体 → 状态检查
部署程序 → 拓展坞
开发控制 → ROS/SDK 层面
```



**Go2 本体的内置主控（控制板）所配置的默认静态 IP 地址**。这块设备**不走 DHCP、也不上公网**，它始终监听这个地址以实现通信

>  “机载电脑 IP 地址为 192.168.123.161”

| 项目     | 说明                                    |
| -------- | --------------------------------------- |
| IP 地址  | `192.168.123.161`（固定写死）           |
| 接口类型 | 有线以太网（连接到拓展坞或其他上位机）  |
| 网络功能 | 局域网通信，仅用于拓展坞与本体通信      |
| 是否可改 | 通常不建议更改，由 Unitree 固定写入配置 |



---

#### **为什么拓展坞加了无线网卡之后，还需要连接 Wi-Fi？**

> ✅ 因为：**无线网卡只是“硬件接口”，只有连接上某个 Wi-Fi 网络，系统才能获得“IP 地址”，才能通信。*



#### 更深入一点解释：

- **无线网卡（Wi-Fi Dongle）本身不提供 IP**，它只是让系统有**“能力”**去连接无线网络
- 真正分配 IP 的是**你连接的那个 Wi-Fi 网络**（路由器、热点、手机分享等）
- 一旦连接上，系统就会从该 Wi-Fi 网络的 DHCP 服务那里获得一个 IP，比如 `192.168.1.88`

| 场景                                     | 是否可以 SSH？ | 原因                                      |
| ---------------------------------------- | -------------- | ----------------------------------------- |
| 插了无线网卡，但没连接 Wi-Fi             | ❌ 不行         | 没有 IP，无法在网络中通信                 |
| 插了无线网卡，连接了你公司或家里的 Wi-Fi | ✅ 可以         | 获取了 IP，可以通过该 IP 被你主机远程访问 |
| 插了无线网卡，但连接失败                 | ❌ 不行         | IP 没有获取，SSH 也无从谈起               |

✔️ Go2 本体 IP 是固定的 `192.168.123.161`，用于和拓展坞通信；
✔️ 无线网卡本身不产生 IP，你必须**连接 Wi-Fi 才能让拓展坞拿到 IP**，这样你才能远程 SSH 进拓展坞



---

#### CMake 的核心作用就是：

> **找出整个项目的源代码结构 + 依赖库 + 编译规则，并生成一个“统一的可执行编译计划”供系统使用。**

CMake 统一的是“编译配置和流程”，它本身不执行编译，而是生成编译工具要用的构建文件





#### 🧠 直白一点讲：

CMake 干的事就像是一个**项目总工程师**，它：

1. **分析你提供的“CMakeLists.txt”规则文件**
2. **找出你项目中需要编译的源代码、用到的头文件、依赖的第三方库**
3. **根据你使用的平台（Linux / Windows）、构建工具（Make / Ninja）生成对应的构建脚本**
4. 最终让你一条命令 `make` 或 `ninja` 就能把项目**“一次性编译成功”**



> **不是直接编译，而是帮你“生成编译方案”**，你再用 `make` 或 `ninja` 去执行它。



### 为什么要用 CMake 而不是手写 gcc？

| 手动写命令                 | 用 CMake 自动管理                  |
| -------------------------- | ---------------------------------- |
| `g++ main.cpp -o main ...` | `cmake . && make`                  |
| 容易漏依赖、难迁移         | 可跨平台、统一管理、多语言混合支持 |
| 写错就爆炸                 | 配置一次，自动生成，维护成本低     |



### 举个例子（Go2 SDK 项目）：

你只要写个像这样的 `CMakeLists.txt` 文件：

```c++
add_executable(main main.cpp)
target_link_libraries(main Go2SDK)
```

然后 CMake 会帮你干这些事：

- 自动找到 `main.cpp`
- 自动找到 `Go2SDK` 的安装路径（可能是 `/opt/unitree/lib`）
- 自动添加 `-I`、`-L` 参数
- 自动生成 `Makefile`



用户电脑连接 Go2 的内置电脑，本质上是为了调用其开放的接口（如状态读取、控制指令）、内置运控服务例程，以进行基本的运动控制测试和状态校验，并不涉及二次开发；其目的是确认设备运行稳定，为后续基于拓展坞的深度开发打好基础

真正的 SDK 部署、算法实现、地图构建等二次开发工作，是在拓展坞（Ubuntu 系统）中完成的，而非 Go2 的内置控制板上

```
“连接 Go2 本体 → 状态检查；部署程序 → 拓展坞；                开发控制 → ROS/SDK 层面”
```



---

```
cd ~/unitree_sdk2/
mkdir build
cd build
cmake ..         
sudo make install

------------------------------------------------------------------------------
目的：
将 Unitree SDK2 项目在本地编译，并安装到系统路径中，让其他程序可以引用 SDK 提供的库和头文件


cmake .. --> 用 CMake 对上一级目录（源码目录）中的 CMakeLists.txt 进行分析并生成 Makefile
sudo make install --> 把刚刚编译出的 SDK 库和头文件，复制到系统标准目录中，供其它项目全局使用

ps.建议装在cmake .. -DCMAKE_INSTALL_PREFIX=/opt/unitree_robotics 中的后缀路径下
```



#### CMakeCache.txt 和 CMakeLists.txt 不等价

| 文件名           | 是否你手写的 | 作用/角色                                | 谁用谁读？               |
| ---------------- | ------------ | ---------------------------------------- | ------------------------ |
| `CMakeLists.txt` | ✅ 你手写的   | 📦 **项目的构建说明书**（源头）           | 你写给 `cmake` 工具看的  |
| `CMakeCache.txt` | ❌ 自动生成   | 🧠 **cmake 运行后生成的缓存结果**（派生） | cmake 自己生成给自己用的 |

- `CMakeLists.txt` 是你告诉 cmake：“我要编译什么、怎么编译”

- `CMakeCache.txt` 是 cmake 执行后说：“好，我记录下你这些指令的参数、路径、结果，方便下次重用”



---



> ####  在 Go2 启动后，它的内置控制系统会**默认启动一套运动控制服务（叫 `sport_mode`）**

这个服务会周期性地向机器人的电机系统发送运动控制指令（比如维持站姿、执行动作、动态控制等）

如果要运行其他的底层运动控制程序，**必须先关闭这个服务**，避免多源控制导致狗动作冲突或失控



#### 关于关闭方式：

| 方式                         | 操作说明                                                  |
| ---------------------------- | --------------------------------------------------------- |
| 📱 用 App 关闭                | 打开 Go2 的官方 App → 设置 → 服务状态 → 关闭 `sport_mode` |
| 🧠 程序中调用 `ServiceSwitch` | 使用 SDK 提供的接口，在代码中通过服务请求关闭该服务       |



### 使用 ServiceSwitch 接口关闭 sport_mode

**1、引入 SDK 头文件**

在您的 C++ 代码中，包含必要的头文件：

```cpp
#include "unitree/robot/go2/service.h"
```



**2、初始化 ROS 节点**

确保您的代码中初始化了 ROS 节点：

```cpp
ros::init(argc, argv, "go2_service_switch");
ros::NodeHandle nh;
```



**3、创建 ServiceSwitch 客户端**

创建一个 ROS 服务客户端，用于调用 `ServiceSwitch` 服务：

```cpp
ros::ServiceClient client = nh.serviceClient<unitree::robot::go2::ServiceSwitch>("service_switch");
```



**4、设置请求参数并调用服务**

创建服务请求，设置要关闭的服务名称为 `sport_mode`，并将状态设置为 `false`：

```cpp
unitree::robot::go2::ServiceSwitch srv;
srv.request.name = "sport_mode";
srv.request.status = false;

if (client.call(srv)) {
    if (srv.response.success) {
        ROS_INFO("Successfully disabled sport_mode.");
    } else {
        ROS_WARN("Failed to disable sport_mode.");
    }
} else {
    ROS_ERROR("Failed to call service ServiceSwitch.");
}
```



**5、编译并运行代码**

使用 CMake 编译您的代码，并在运行前确保 ROS 节点已启动







---



## 详细二次开发流程（你该做什么）

### 🎯 Step 1：远程连接拓展坞（Ubuntu）

```
ssh ubuntu@192.168.X.XX   # 进入拓展坞系统
```

你现在就像“坐在狗背上的开发者”了。

### 🎯 Step 2：检查/准备 ROS 开发环境

```
source /opt/ros/foxy/setup.bash   # 载入 ROS 环境（假设你用的是 ROS2）
ros2 topic list                   # 看看当前有哪些话题（比如 /odom /imu /scan）
```

你应该能看到雷达数据、IMU 数据等。

### 🎯 Step 3：创建你的工作空间并编写 ROS 节点

```
mkdir -p ~/my_ws/src
cd ~/my_ws
colcon build
source install/setup.bash
```

#### 你写的节点是这样的（以 Python 为例）：

```
# my_ws/src/my_pkg/my_node.py
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Imu

class ImuLogger(Node):
    def __init__(self):
        super().__init__('imu_logger')
        self.subscription = self.create_subscription(
            Imu,
            '/imu/data',
            self.listener_callback,
            10
        )

    def listener_callback(self, msg):
        self.get_logger().info(f"Got IMU: {msg.orientation}")

rclpy.init()
rclpy.spin(ImuLogger())
rclpy.shutdown()
```

你就做了一件事：**监听了** `**/imu/data**` **话题并打印输出**。

### 🎯 Step 4：部署/运行你的节点

```
cd ~/my_ws
colcon build
source install/setup.bash
ros2 run my_pkg my_node
```

现在你就从 Go2 的雷达 / IMU 等设备中订阅了数据，准备做更多逻辑（如：建图、避障、控制移动）。

## ✅ 四、主控板和拓展坞怎么协作？

| 功能                | 由谁负责                | 说明                               |
| ------------------- | ----------------------- | ---------------------------------- |
| 电机控制            | Go2 主控                | 通过内部协议响应控制指令           |
| 控制发出（cmd_vel） | 你写的 ROS 节点在拓展坞 | 你向话题 `/cmd_vel` 发送指令       |
| 雷达数据采集        | 雷达 → 拓展坞           | 点云直接接入拓展坞处理             |
| 位姿估计（SLAM）    | 你在拓展坞写的程序      | 融合 IMU + Odom 实现地图构建与导航 |

## ✅ 五、拓展建议：

- 用 `rviz2` 在拓展坞本地或远程查看 SLAM 地图
- 使用 `ros2 bag record` 记录数据包，调试你的算法
- 将你的程序放入 `systemd` 实现自动上电启动

## ✅ 最后一张总结图（逻辑结构）

```
[你的主机]（虚拟机也行）
   └── SSH / VNC
       ↓
[拓展坞 Ubuntu] ←→ 雷达、D435、IMU
       ↓             ↑
    ROS 节点：      Go2 主控执行动作
    - 订阅话题
    - 发布控制
    - 构建地图
```













---

**绝大多数设备之所以“没有暴露在公网”，是因为它们被放在了一个**“内网环境”**里，而这个环境的对外出口是由一个叫 NAT 的东西统一管理的。**

| 类型    | 地址段（典型）             | 是否能被外部设备直接访问？   | 举例                           |
| ------- | -------------------------- | ---------------------------- | ------------------------------ |
| 公网 IP | 如：115.24.33.108          | ✅ 能，互联网上任何人都能连上 | 腾讯云服务器、Web站、堡垒机    |
| 内网 IP | 如：192.168.x.x / 10.x.x.x | ❌ 不能直接连，要通过出口转发 | 家里电脑、打印机、公司内部设备 |

#### 真正起作用的是 **NAT（网络地址转换）技术**

> **NAT（Network Address Translation）**是路由器最常见的功能，它的作用就是：
>
> ✅ “把家里所有的设备的请求，统一通过一个公网 IP 发出去”
> ✅ “而外面的世界并不知道你家里面有几台设备，它只看到你家的门口 IP”



```
🧠 举个形象比喻来解释 NAT：

你家住的是 一栋大楼（内网），你家有 192.168.1.101、102、103 三个人（设备）
整栋楼只有一个门口（公网 IP）叫 115.24.33.108（这就是你路由器）
外面的快递只能送到大门口（公网）
但送不进具体房间（内网）除非你**“主动开门”或“登记门牌映射”（端口映射）**
```

- NAT统一管理内网设备出口
- 主动不暴露内网设备
- 端口映射 / DMZ，可以把某台内网设备映射到公网





---



#### 开放端口为什么不会暴露整个网段？

#### ✅ 原因本质：**开放的是“某个端口”，不是“整个 IP 网段”**



#### 就算别人“猜”到你内网的地址（比如 192.168.31.25）：

- 他们也无法直接发包到那台机器上
- NAT + 路由器防火墙机制 **会拦住它**
- 除非你“主动开门”（端口映射），否则打不进去













---

### 远程连接方式：

| 方式 | 功能             | 使用场景                     |
| ---- | ---------------- | ---------------------------- |
| SSH  | 命令行终端       | 轻量级操作、写代码、编译     |
| VNC  | 图形界面远程桌面 | 可运行 RViz、使用 GUI 工具等 |









